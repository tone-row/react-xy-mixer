{"ast":null,"code":"var _jsxFileName = \"/Users/robgordon/Dev/react-xy-mixer/docs/src/components/Mixer.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { forwardRef, useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport \"./Mixer.css\";\nimport { array2mat, solve, min, sub, sum, entrywisediv } from \"./lalolib\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DEFAULT_SIZE = 300;\n\nfunction getNumNodes(nodes) {\n  return typeof nodes === \"number\" ? nodes : nodes.length;\n}\n\nconst handleSize = 10;\nconst DefaultHandle = /*#__PURE__*/forwardRef(_c = ({\n  center\n}, handle) => /*#__PURE__*/_jsxDEV(\"circle\", {\n  className: \"multi-range__handler handle\",\n  cx: center.x,\n  cy: center.y,\n  r: handleSize,\n  ref: handle\n}, void 0, false, {\n  fileName: _jsxFileName,\n  lineNumber: 41,\n  columnNumber: 5\n}, this));\n_c2 = DefaultHandle;\nexport function useMixer(initialNodes, options = {\n  size: DEFAULT_SIZE,\n  rotate: 0,\n  handleOffset: 0,\n  boundary: \"box\",\n  initial: 0,\n  handle: DefaultHandle\n}) {\n  _s();\n\n  var _options$initial, _options$handleOffset, _options$boundary, _options$handle;\n\n  // need to effectually update i guess???\n  const [nodes] = useState(initialNodes);\n  const {\n    size = DEFAULT_SIZE\n  } = options;\n  const setup = useMemo(() => {\n    let arrayOfNodes = Array.isArray(nodes) ? nodes : Array(nodes).fill(0).map((_, i) => {\n      var _options$rotate;\n\n      return getPointCoord(0.5, i * (2 * Math.PI / nodes) - (Math.PI / 2 + ((_options$rotate = options.rotate) !== null && _options$rotate !== void 0 ? _options$rotate : 0)));\n    }); // normalize coordinates\n\n    const xsYs = arrayOfNodes.reduce((acc, node) => [acc[0].concat(node[0]), acc[1].concat(node[1])], [[], []]);\n    const limits = {\n      xMin: Math.min(...xsYs[0]),\n      xMax: Math.max(...xsYs[0]),\n      yMin: Math.min(...xsYs[1]),\n      yMax: Math.max(...xsYs[1])\n    };\n    const normalizedNodes = arrayOfNodes.map(([x, y]) => [(x - limits.xMin) / (limits.xMax - limits.xMin), // stretch out the y axis accordingly\n    y / (limits.xMax - limits.xMin)]); // map coordinates [0-1,] to SVG size\n\n    const resizedNodes = normalizedNodes.reduce((acc, point) => {\n      return [...acc, point.map(p => p * size)];\n    }, []);\n    return {\n      n: resizedNodes.length,\n      nodes: resizedNodes,\n      mode: Array.isArray(nodes) ? \"MANUAL\" : \"AUTO\"\n    };\n  }, [nodes, options.rotate, size]);\n  let startNode = (_options$initial = options.initial) !== null && _options$initial !== void 0 ? _options$initial : 0;\n  if (startNode < 0 || startNode > setup.nodes.length - 1) throw new Error(`Initial ${startNode} is not valid.`); // This should actually correspond to the starting position probably\n\n  const [weights, setWeights] = useState(Array(getNumNodes(nodes)).fill(0).map((_, i) => i === startNode ? 1 : 0));\n  const [center, setCenter] = useState({\n    x: setup.nodes[startNode][0],\n    y: setup.nodes[startNode][1]\n  });\n  let componentProps = {\n    setWeights,\n    size,\n    n: setup.n,\n    nodes: setup.nodes,\n    mode: setup.mode,\n    handleOffset: (_options$handleOffset = options.handleOffset) !== null && _options$handleOffset !== void 0 ? _options$handleOffset : 0,\n    boundary: ((_options$boundary = options.boundary) !== null && _options$boundary !== void 0 ? _options$boundary : setup.mode === \"AUTO\") ? \"polygon\" : \"box\",\n    center,\n    setCenter,\n    handle: (_options$handle = options.handle) !== null && _options$handle !== void 0 ? _options$handle : DefaultHandle\n  };\n  return [componentProps, weights];\n}\n\n_s(useMixer, \"rOjukRSsD0dsrlALFAkptr81hLo=\");\n\n// need to scope svg boundary definition\n// for when multiple elements on the same page\n// because SVG's share definition scope\nlet defScopeIncrement = 0;\nexport default function Mixer(props) {\n  _s2();\n\n  var _props$style;\n\n  let {\n    n,\n    size,\n    setWeights,\n    nodes,\n    boundary,\n    handleOffset = 0,\n    mode,\n    center,\n    setCenter,\n    handle: Handle,\n    ...svgProps\n  } = props;\n  const id = useRef(`boundary-${defScopeIncrement++}`);\n  const handle = useRef(null);\n  const {\n    boundaryFns,\n    box,\n    matrix\n  } = useMemo(() => {\n    let matrix = [];\n\n    for (const p1 of nodes) {\n      let n = [];\n\n      for (const p2 of nodes) {\n        n.push(innerProduct(p1, p2));\n      }\n\n      matrix.push(n);\n    } // @ts-ignore\n\n\n    matrix = array2mat(matrix);\n    const box = nodes.reduce((acc, point) => ({\n      yMin: Math.min(acc.yMin, point[1]),\n      yMax: Math.max(acc.yMax, point[1]),\n      xMin: Math.min(acc.xMin, point[0]),\n      xMax: Math.max(acc.xMax, point[0])\n    }), {\n      yMin: size,\n      yMax: 0,\n      xMin: size,\n      xMax: 0\n    }); // This should be determined by boundary strategy\n\n    const boundaryFns = boundary === \"polygon\" ? getAutoLayoutBoundaryFns(nodes) : {\n      [box.yMin - handleOffset]: {\n        [box.yMax + handleOffset]: [_y => box.xMin, _y => box.xMax]\n      }\n    };\n    return {\n      boundaryFns,\n      box,\n      matrix\n    };\n  }, [boundary, handleOffset, nodes, size]); // Function to get x axis boundary from y value\n\n  const getBounds = useCallback(currentY => {\n    let fns = []; // make sure y is bounded\n\n    const y = Math.max(Math.min(currentY, box.yMax), box.yMin);\n\n    for (const minY of Object.keys(boundaryFns)) {\n      if (y >= parseFloat(minY)) {\n        for (const maxY of Object.keys(boundaryFns[parseFloat(minY)])) {\n          if (y <= parseFloat(maxY)) {\n            fns = fns.concat(boundaryFns[parseFloat(minY)][parseFloat(maxY)]);\n          }\n        }\n      }\n    }\n\n    const fnResults = fns.map(f => f(y));\n    const xs = fnResults.sort((a, b) => a - b);\n\n    if (n === 1) {\n      return {\n        minX: size / 2,\n        maxX: size / 2,\n        y\n      };\n    } else if (n === 2) {\n      return {\n        minX: 0,\n        maxX: size,\n        y\n      };\n    } else {\n      return {\n        minX: Math.min(...xs),\n        maxX: Math.max(...xs),\n        y\n      };\n    }\n  }, [boundaryFns, box.yMax, box.yMin, n, size]);\n  const getWeights = useCallback(({\n    x: x1,\n    y: y1\n  }) => {\n    let m = [];\n\n    for (const point of nodes) {\n      m.push(innerProduct([x1, y1], point));\n    } // @ts-ignore\n\n\n    m = array2mat(m); // @ts-ignore\n\n    const result = solve(matrix, m); //@ts-ignore\n\n    const x = sub(result, min(result)); //@ts-ignore\n\n    const final = entrywisediv(x, sum(x));\n    return final;\n  }, [matrix, nodes]);\n  useEffect(() => {\n    const cHandle = handle.current;\n\n    if (cHandle) {\n      var _cHandle$parentNode;\n\n      let svg = (_cHandle$parentNode = cHandle.parentNode) === null || _cHandle$parentNode === void 0 ? void 0 : _cHandle$parentNode.parentNode;\n\n      const getMousePosition = evt => {\n        var CTM = svg.getScreenCTM();\n        let e = \"touches\" in evt ? evt.touches[0] : evt;\n\n        if (CTM && e) {\n          return {\n            x: (e.clientX - CTM.e) / CTM.a,\n            y: (e.clientY - CTM.f) / CTM.d\n          };\n        }\n\n        return null;\n      };\n\n      let isDragging = false;\n\n      const startDrag = e => {\n        isDragging = true;\n        drag(e);\n      };\n\n      const drag = e => {\n        if (isDragging) {\n          e.preventDefault();\n          e.stopPropagation();\n          const coord = getMousePosition(e);\n\n          if (coord) {\n            const bounds = getBounds(coord.y);\n            let boundedCoord = {\n              x: Math.max(Math.min(coord.x, bounds.maxX), bounds.minX),\n              y: bounds.y\n            }; // get distance from each point\n\n            const w = getWeights(boundedCoord);\n            setWeights(w);\n            setCenter(boundedCoord);\n          }\n        }\n      };\n\n      const endDrag = e => {\n        isDragging = false;\n      };\n\n      svg.addEventListener(\"mousedown\", startDrag);\n      window.addEventListener(\"mousemove\", drag);\n      window.addEventListener(\"mouseup\", endDrag);\n      window.addEventListener(\"mouseleave\", endDrag); // Mobile\n\n      svg.addEventListener(\"touchstart\", startDrag);\n      window.addEventListener(\"touchmove\", drag, {\n        passive: false\n      });\n      window.addEventListener(\"touchend\", endDrag);\n      window.addEventListener(\"touchleave\", endDrag);\n      window.addEventListener(\"touchcancel\", endDrag);\n      return () => {\n        svg.removeEventListener(\"mousedown\", startDrag);\n        window.removeEventListener(\"mousemove\", drag);\n        window.removeEventListener(\"mouseup\", endDrag);\n        window.removeEventListener(\"mouseleave\", endDrag);\n        svg.removeEventListener(\"touchstart\", startDrag);\n        window.removeEventListener(\"touchmove\", drag);\n        window.removeEventListener(\"touchend\", endDrag);\n        window.removeEventListener(\"touchleave\", endDrag);\n        window.removeEventListener(\"touchcancel\", endDrag);\n      };\n    }\n  }, [getBounds, getWeights, setCenter, setWeights]);\n  const viewBox = `${box.xMin - handleOffset} ${box.yMin - handleOffset} ${2 * handleOffset + box.xMax - box.xMin} ${2 * handleOffset + box.yMax - box.yMin}`;\n  return /*#__PURE__*/_jsxDEV(\"svg\", { ...svgProps,\n    className: [\"multi-range\", props.className].filter(Boolean).join(\" \"),\n    viewBox: viewBox,\n    width: box.xMax - box.xMin,\n    height: box.yMax - box.yMin,\n    style: { ...((_props$style = props.style) !== null && _props$style !== void 0 ? _props$style : {})\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"defs\", {\n      children: [/*#__PURE__*/_jsxDEV(\"polygon\", {\n        id: id.current,\n        points: nodes.map(point => point.join(\",\")).join(\" \")\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 379,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"clipPath\", {\n        id: \"clip\",\n        children: /*#__PURE__*/_jsxDEV(\"use\", {\n          xlinkHref: `#${id.current}`\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 384,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 383,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 378,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"g\", {\n      children: [/*#__PURE__*/_jsxDEV(\"use\", {\n        xlinkHref: `#${id.current}`,\n        className: \"multi-range__polygon polygon\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 388,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(Handle, {\n        center: center,\n        ref: handle\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 392,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 387,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 366,\n    columnNumber: 5\n  }, this);\n}\n\n_s2(Mixer, \"9oGjxRfl6gTgRE6ToCC3llK3EQc=\");\n\n_c3 = Mixer;\n\nfunction innerProduct(a, b) {\n  return a[0] * b[0] + a[1] + b[1];\n}\n\nfunction round(n, z = 5) {\n  const x = Math.pow(10, 5);\n  return Math.round(n * x) / x;\n}\n\nfunction getPointCoord(radius, radian) {\n  return [round(radius * Math.cos(radian) + radius), round(radius * Math.sin(radian) + radius)];\n}\n/**\n * This function returns the boundary functions which are used to determine the bounds of the handle.\n */\n\n\nfunction getAutoLayoutBoundaryFns(nodes) {\n  const pairs = Array(nodes.length).fill(null).map((_, index) => {\n    return [nodes[index], nodes[(index + 1) % nodes.length]];\n  });\n  return pairs.reduce((acc, pair) => {\n    const [point1, point2] = pair.sort((a, b) => a[1] - b[1]);\n    const [minY, maxY] = [point1[1], point2[1]].sort((a, b) => a - b);\n\n    if (!(minY in acc)) {\n      acc[minY] = {};\n    }\n\n    if (!(maxY in acc[minY])) {\n      acc[minY][maxY] = [];\n    }\n\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n    const m = (y2 - y1) / (x2 - x1); // Remove horizontal lines (no slope)\n    // but accounting for rounding error\n\n    if (Math.abs(m) > 0.0000001) {\n      acc[minY][maxY].push(y => {\n        const slope = (y - y1) / m;\n        const result = x1 + slope;\n        return result !== null && result !== void 0 ? result : 0;\n      });\n    }\n\n    return acc;\n  }, {});\n}\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"DefaultHandle$forwardRef\");\n$RefreshReg$(_c2, \"DefaultHandle\");\n$RefreshReg$(_c3, \"Mixer\");","map":{"version":3,"sources":["/Users/robgordon/Dev/react-xy-mixer/docs/src/components/Mixer.tsx"],"names":["forwardRef","useCallback","useEffect","useMemo","useRef","useState","array2mat","solve","min","sub","sum","entrywisediv","DEFAULT_SIZE","getNumNodes","nodes","length","handleSize","DefaultHandle","center","handle","x","y","useMixer","initialNodes","options","size","rotate","handleOffset","boundary","initial","setup","arrayOfNodes","Array","isArray","fill","map","_","i","getPointCoord","Math","PI","xsYs","reduce","acc","node","concat","limits","xMin","xMax","max","yMin","yMax","normalizedNodes","resizedNodes","point","p","n","mode","startNode","Error","weights","setWeights","setCenter","componentProps","defScopeIncrement","Mixer","props","Handle","svgProps","id","boundaryFns","box","matrix","p1","p2","push","innerProduct","getAutoLayoutBoundaryFns","_y","getBounds","currentY","fns","minY","Object","keys","parseFloat","maxY","fnResults","f","xs","sort","a","b","minX","maxX","getWeights","x1","y1","m","result","final","cHandle","current","svg","parentNode","getMousePosition","evt","CTM","getScreenCTM","e","touches","clientX","clientY","d","isDragging","startDrag","drag","preventDefault","stopPropagation","coord","bounds","boundedCoord","w","endDrag","addEventListener","window","passive","removeEventListener","viewBox","className","filter","Boolean","join","style","round","z","pow","radius","radian","cos","sin","pairs","index","pair","point1","point2","x2","y2","abs","slope"],"mappings":"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","sourcesContent":["import {\n  CSSProperties,\n  Dispatch,\n  forwardRef,\n  ForwardRefExoticComponent,\n  RefAttributes,\n  SetStateAction,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport \"./Mixer.css\";\nimport { array2mat, solve, min, sub, sum, entrywisediv } from \"./lalolib\";\n\ntype LayoutMode = \"MANUAL\" | \"AUTO\";\n\nconst DEFAULT_SIZE = 300;\n\ninterface useMixerOptions {\n  size?: number;\n  rotate?: number;\n  handleOffset?: number;\n  boundary?: \"polygon\" | \"box\";\n  initial?: number;\n  handle?: ForwardRefExoticComponent<\n    MixerHandleProps & RefAttributes<any | null>\n  >;\n}\n\nfunction getNumNodes(nodes: number | number[][]) {\n  return typeof nodes === \"number\" ? nodes : nodes.length;\n}\n\nconst handleSize = 10;\n\nexport type MixerHandleProps = { center: { x: number; y: number } };\nconst DefaultHandle = forwardRef<SVGCircleElement | null, MixerHandleProps>(\n  ({ center }, handle) => (\n    <circle\n      className=\"multi-range__handler handle\"\n      cx={center.x}\n      cy={center.y}\n      r={handleSize}\n      ref={handle}\n    />\n  )\n);\n\nexport function useMixer(\n  initialNodes: number | number[][],\n  options: useMixerOptions = {\n    size: DEFAULT_SIZE,\n    rotate: 0,\n    handleOffset: 0,\n    boundary: \"box\",\n    initial: 0,\n    handle: DefaultHandle,\n  }\n): [MixerProps, number[]] {\n  // need to effectually update i guess???\n  const [nodes] = useState(initialNodes);\n  const { size = DEFAULT_SIZE } = options;\n\n  const setup = useMemo(() => {\n    let arrayOfNodes = Array.isArray(nodes)\n      ? nodes\n      : Array(nodes)\n          .fill(0)\n          .map((_, i) =>\n            getPointCoord(\n              0.5,\n              i * ((2 * Math.PI) / nodes) -\n                (Math.PI / 2 + (options.rotate ?? 0))\n            )\n          );\n\n    // normalize coordinates\n    const xsYs = arrayOfNodes.reduce(\n      (acc, node) => [acc[0].concat(node[0]), acc[1].concat(node[1])],\n      [[], []] as number[][]\n    );\n\n    const limits = {\n      xMin: Math.min(...xsYs[0]),\n      xMax: Math.max(...xsYs[0]),\n      yMin: Math.min(...xsYs[1]),\n      yMax: Math.max(...xsYs[1]),\n    };\n\n    const normalizedNodes = arrayOfNodes.map(([x, y]) => [\n      (x - limits.xMin) / (limits.xMax - limits.xMin),\n      // stretch out the y axis accordingly\n      y / (limits.xMax - limits.xMin),\n    ]);\n\n    // map coordinates [0-1,] to SVG size\n    const resizedNodes = normalizedNodes.reduce((acc, point) => {\n      return [...acc, point.map((p) => p * size)];\n    }, [] as number[][]);\n\n    return {\n      n: resizedNodes.length,\n      nodes: resizedNodes,\n      mode: Array.isArray(nodes)\n        ? (\"MANUAL\" as LayoutMode)\n        : (\"AUTO\" as LayoutMode),\n    };\n  }, [nodes, options.rotate, size]);\n\n  let startNode = options.initial ?? 0;\n  if (startNode < 0 || startNode > setup.nodes.length - 1)\n    throw new Error(`Initial ${startNode} is not valid.`);\n\n  // This should actually correspond to the starting position probably\n  const [weights, setWeights] = useState<number[]>(\n    Array(getNumNodes(nodes))\n      .fill(0)\n      .map((_, i) => (i === startNode ? 1 : 0))\n  );\n\n  const [center, setCenter] = useState({\n    x: setup.nodes[startNode][0],\n    y: setup.nodes[startNode][1],\n  });\n\n  let componentProps: MixerProps = {\n    setWeights,\n    size,\n    n: setup.n,\n    nodes: setup.nodes,\n    mode: setup.mode,\n    handleOffset: options.handleOffset ?? 0,\n    boundary: options.boundary ?? setup.mode === \"AUTO\" ? \"polygon\" : \"box\",\n    center,\n    setCenter,\n    handle: options.handle ?? DefaultHandle,\n  };\n\n  return [componentProps, weights];\n}\n\ninterface MixerProps {\n  size: number;\n  handleOffset: number;\n  setWeights: Dispatch<SetStateAction<number[]>>;\n  n: number;\n  nodes: number[][];\n  boundary: \"polygon\" | \"box\"; // 'user'\n  mode: \"AUTO\" | \"MANUAL\";\n  center: {\n    x: number;\n    y: number;\n  };\n  setCenter: Dispatch<\n    SetStateAction<{\n      x: number;\n      y: number;\n    }>\n  >;\n  handle: ForwardRefExoticComponent<\n    MixerHandleProps & RefAttributes<any | null>\n  >;\n}\n\n// need to scope svg boundary definition\n// for when multiple elements on the same page\n// because SVG's share definition scope\nlet defScopeIncrement = 0;\n\nexport default function Mixer(\n  props: MixerProps & React.SVGProps<SVGSVGElement>\n) {\n  let {\n    n,\n    size,\n    setWeights,\n    nodes,\n    boundary,\n    handleOffset = 0,\n    mode,\n    center,\n    setCenter,\n    handle: Handle,\n    ...svgProps\n  } = props;\n\n  const id = useRef(`boundary-${defScopeIncrement++}`);\n\n  const handle = useRef<SVGCircleElement | null>(null);\n\n  const { boundaryFns, box, matrix } = useMemo(() => {\n    let matrix = [];\n    for (const p1 of nodes) {\n      let n = [];\n      for (const p2 of nodes) {\n        n.push(innerProduct(p1, p2));\n      }\n      matrix.push(n);\n    }\n\n    // @ts-ignore\n    matrix = array2mat(matrix);\n\n    const box = nodes.reduce(\n      (acc, point) => ({\n        yMin: Math.min(acc.yMin, point[1]),\n        yMax: Math.max(acc.yMax, point[1]),\n        xMin: Math.min(acc.xMin, point[0]),\n        xMax: Math.max(acc.xMax, point[0]),\n      }),\n      {\n        yMin: size,\n        yMax: 0,\n        xMin: size,\n        xMax: 0,\n      }\n    );\n\n    // This should be determined by boundary strategy\n    const boundaryFns =\n      boundary === \"polygon\"\n        ? getAutoLayoutBoundaryFns(nodes)\n        : {\n            [box.yMin - handleOffset]: {\n              [box.yMax + handleOffset]: [\n                (_y: number) => box.xMin,\n                (_y: number) => box.xMax,\n              ],\n            },\n          };\n\n    return { boundaryFns, box, matrix };\n  }, [boundary, handleOffset, nodes, size]);\n\n  // Function to get x axis boundary from y value\n  const getBounds = useCallback(\n    (currentY: number) => {\n      let fns = [] as ((y: number) => number)[];\n      // make sure y is bounded\n      const y = Math.max(Math.min(currentY, box.yMax), box.yMin);\n\n      for (const minY of Object.keys(boundaryFns)) {\n        if (y >= parseFloat(minY)) {\n          for (const maxY of Object.keys(boundaryFns[parseFloat(minY)])) {\n            if (y <= parseFloat(maxY)) {\n              fns = fns.concat(boundaryFns[parseFloat(minY)][parseFloat(maxY)]);\n            }\n          }\n        }\n      }\n\n      const fnResults = fns.map((f) => f(y));\n      const xs = fnResults.sort((a, b) => a - b);\n      if (n === 1) {\n        return { minX: size / 2, maxX: size / 2, y };\n      } else if (n === 2) {\n        return { minX: 0, maxX: size, y };\n      } else {\n        return { minX: Math.min(...xs), maxX: Math.max(...xs), y };\n      }\n    },\n    [boundaryFns, box.yMax, box.yMin, n, size]\n  );\n\n  const getWeights = useCallback(\n    ({ x: x1, y: y1 }: { x: number; y: number }) => {\n      let m = [];\n      for (const point of nodes) {\n        m.push(innerProduct([x1, y1], point));\n      }\n      // @ts-ignore\n      m = array2mat(m);\n\n      // @ts-ignore\n      const result = solve(matrix, m);\n\n      //@ts-ignore\n      const x = sub(result, min(result));\n      //@ts-ignore\n      const final = entrywisediv(x, sum(x));\n\n      return final as number[];\n    },\n    [matrix, nodes]\n  );\n\n  useEffect(() => {\n    const cHandle = handle.current;\n    if (cHandle) {\n      let svg = cHandle.parentNode?.parentNode as SVGSVGElement;\n      const getMousePosition = (evt: MouseEvent | TouchEvent) => {\n        var CTM = svg.getScreenCTM();\n        let e = \"touches\" in evt ? evt.touches[0] : evt;\n        if (CTM && e) {\n          return {\n            x: (e.clientX - CTM.e) / CTM.a,\n            y: (e.clientY - CTM.f) / CTM.d,\n          };\n        }\n        return null;\n      };\n\n      let isDragging = false;\n      const startDrag = (e: MouseEvent | TouchEvent) => {\n        isDragging = true;\n        drag(e);\n      };\n\n      const drag = (e: MouseEvent | TouchEvent) => {\n        if (isDragging) {\n          e.preventDefault();\n          e.stopPropagation();\n          const coord = getMousePosition(e);\n          if (coord) {\n            const bounds = getBounds(coord.y);\n            let boundedCoord = {\n              x: Math.max(Math.min(coord.x, bounds.maxX), bounds.minX),\n              y: bounds.y,\n            };\n            // get distance from each point\n            const w = getWeights(boundedCoord);\n            setWeights(w);\n            setCenter(boundedCoord);\n          }\n        }\n      };\n\n      const endDrag: EventListener = (e) => {\n        isDragging = false;\n      };\n\n      svg.addEventListener(\"mousedown\", startDrag);\n      window.addEventListener(\"mousemove\", drag);\n      window.addEventListener(\"mouseup\", endDrag);\n      window.addEventListener(\"mouseleave\", endDrag);\n\n      // Mobile\n      svg.addEventListener(\"touchstart\", startDrag);\n      window.addEventListener(\"touchmove\", drag, { passive: false });\n      window.addEventListener(\"touchend\", endDrag);\n      window.addEventListener(\"touchleave\", endDrag);\n      window.addEventListener(\"touchcancel\", endDrag);\n\n      return () => {\n        svg.removeEventListener(\"mousedown\", startDrag);\n        window.removeEventListener(\"mousemove\", drag);\n        window.removeEventListener(\"mouseup\", endDrag);\n        window.removeEventListener(\"mouseleave\", endDrag);\n\n        svg.removeEventListener(\"touchstart\", startDrag);\n        window.removeEventListener(\"touchmove\", drag);\n        window.removeEventListener(\"touchend\", endDrag);\n        window.removeEventListener(\"touchleave\", endDrag);\n        window.removeEventListener(\"touchcancel\", endDrag);\n      };\n    }\n  }, [getBounds, getWeights, setCenter, setWeights]);\n\n  const viewBox = `${box.xMin - handleOffset} ${box.yMin - handleOffset} ${\n    2 * handleOffset + box.xMax - box.xMin\n  } ${2 * handleOffset + box.yMax - box.yMin}`;\n\n  return (\n    <svg\n      {...svgProps}\n      className={[\"multi-range\", props.className].filter(Boolean).join(\" \")}\n      viewBox={viewBox}\n      width={box.xMax - box.xMin}\n      height={box.yMax - box.yMin}\n      style={\n        {\n          ...(props.style ?? {}),\n        } as CSSProperties\n      }\n    >\n      <defs>\n        <polygon\n          id={id.current}\n          points={nodes.map((point) => point.join(\",\")).join(\" \")}\n        />\n        <clipPath id=\"clip\">\n          <use xlinkHref={`#${id.current}`} />\n        </clipPath>\n      </defs>\n      <g>\n        <use\n          xlinkHref={`#${id.current}`}\n          className=\"multi-range__polygon polygon\"\n        />\n        <Handle center={center} ref={handle} />\n      </g>\n    </svg>\n  );\n}\n\nfunction innerProduct(a: number[], b: number[]) {\n  return a[0] * b[0] + a[1] + b[1];\n}\n\nfunction round(n: number, z: number = 5) {\n  const x = Math.pow(10, 5);\n  return Math.round(n * x) / x;\n}\n\nfunction getPointCoord(radius: number, radian: number) {\n  return [\n    round(radius * Math.cos(radian) + radius),\n    round(radius * Math.sin(radian) + radius),\n  ];\n}\n\n/**\n * This function returns the boundary functions which are used to determine the bounds of the handle.\n */\nfunction getAutoLayoutBoundaryFns(nodes: number[][]) {\n  const pairs = Array(nodes.length)\n    .fill(null)\n    .map((_, index) => {\n      return [nodes[index], nodes[(index + 1) % nodes.length]];\n    });\n  return pairs.reduce((acc, pair) => {\n    const [point1, point2] = pair.sort((a, b) => a[1] - b[1]);\n    const [minY, maxY] = [point1[1], point2[1]].sort((a, b) => a - b);\n    if (!(minY in acc)) {\n      acc[minY] = {};\n    }\n    if (!(maxY in acc[minY])) {\n      acc[minY][maxY] = [];\n    }\n\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n    const m = (y2 - y1) / (x2 - x1);\n    // Remove horizontal lines (no slope)\n    // but accounting for rounding error\n    if (Math.abs(m) > 0.0000001) {\n      acc[minY][maxY].push((y: number) => {\n        const slope = (y - y1) / m;\n        const result = x1 + slope;\n        return result ?? 0;\n      });\n    }\n\n    return acc;\n  }, {} as Record<number, Record<number, ((y: number) => number)[]>>);\n}\n"]},"metadata":{},"sourceType":"module"}